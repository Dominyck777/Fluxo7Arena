with schemas_included as (
    select n.nspname as schema_name
    from pg_namespace n
    where n.nspname not like 'pg_%'
      and n.nspname <> 'information_schema'
)

select 
    'schema' as object_type,
    n.nspname as schema_name,
    n.nspname as object_name,
    null as parent_object,
    null as extra_info,
    pg_get_userbyid(n.nspowner) as owner,
    obj_description(n.oid, 'pg_namespace') as comment
from pg_namespace n
join schemas_included si on si.schema_name = n.nspname

union all
select 
    'table',
    n.nspname,
    c.relname,
    null,
    case c.relkind
        when 'r' then 'table'
        when 'v' then 'view'
        when 'm' then 'materialized_view'
        else c.relkind::text
    end,
    pg_get_userbyid(c.relowner),
    obj_description(c.oid, 'pg_class')
from pg_class c
join pg_namespace n on n.oid = c.relnamespace
join schemas_included si on si.schema_name = n.nspname
where c.relkind in ('r','v','m')

union all
select 
    'column',
    n.nspname,
    a.attname,
    c.relname,
    pg_catalog.format_type(a.atttypid, a.atttypmod) 
      || ' default ' || coalesce(pg_get_expr(d.adbin, d.adrelid), 'null'),
    null,
    col_description(a.attrelid, a.attnum)
from pg_attribute a
join pg_class c on c.oid = a.attrelid
join pg_namespace n on n.oid = c.relnamespace
left join pg_attrdef d on d.adrelid = a.attrelid and d.adnum = a.attnum
join schemas_included si on si.schema_name = n.nspname
where a.attnum > 0 and not a.attisdropped

union all
select 
    'constraint',
    n.nspname,
    con.conname,
    c.relname,
    pg_get_constraintdef(con.oid),
    null,
    null
from pg_constraint con
join pg_class c on c.oid = con.conrelid
join pg_namespace n on n.oid = c.relnamespace
join schemas_included si on si.schema_name = n.nspname

union all
select
    'index',
    n.nspname,
    i.relname,
    t.relname,
    pg_get_indexdef(ix.indexrelid),
    null,
    null
from pg_index ix
join pg_class t on t.oid = ix.indrelid
join pg_class i on i.oid = ix.indexrelid
join pg_namespace n on n.oid = t.relnamespace
join schemas_included si on si.schema_name = n.nspname

union all
select
    'trigger',
    n.nspname,
    t.tgname,
    c.relname,
    pg_get_triggerdef(t.oid),
    null,
    obj_description(t.oid, 'pg_trigger')
from pg_trigger t
join pg_class c on c.oid = t.tgrelid
join pg_namespace n on n.oid = c.relnamespace
join schemas_included si on si.schema_name = n.nspname
where not t.tgisinternal

union all
select
    'function',
    n.nspname,
    p.proname,
    null,
    '(' || pg_get_function_identity_arguments(p.oid) || ') returns ' || pg_get_function_result(p.oid),
    pg_get_userbyid(p.proowner),
    obj_description(p.oid, 'pg_proc')
from pg_proc p
join pg_namespace n on n.oid = p.pronamespace
join schemas_included si on si.schema_name = n.nspname

union all
select
    'sequence',
    n.nspname,
    c.relname,
    null,
    'increment ' || coalesce(seq.seqincrement::text, '?')
        || ', min ' || coalesce(seq.seqmin::text, '?')
        || ', max ' || coalesce(seq.seqmax::text, '?'),
    pg_get_userbyid(c.relowner),
    obj_description(c.oid, 'pg_class')
from pg_class c
join pg_namespace n on n.oid = c.relnamespace
join schemas_included si on si.schema_name = n.nspname
left join pg_sequence seq on seq.seqrelid = c.oid
where c.relkind = 'S'

union all
select
    'type',
    n.nspname,
    t.typname,
    null,
    pg_catalog.format_type(t.oid, null),
    null,
    obj_description(t.oid, 'pg_type')
from pg_type t
join pg_namespace n on n.oid = t.typnamespace
join schemas_included si on si.schema_name = n.nspname
where t.typtype in ('e','c','d')

union all
select
    'extension',
    n.nspname,
    e.extname,
    null,
    e.extversion,
    null,
    obj_description(e.oid, 'pg_extension')
from pg_extension e
left join pg_namespace n on n.oid = e.extnamespace

union all
select
    'grant',
    n.nspname,
    c.relname,
    null,
    pg_catalog.array_to_string(c.relacl, ','),
    pg_get_userbyid(c.relowner),
    null
from pg_class c
join pg_namespace n on n.oid = c.relnamespace
join schemas_included si on si.schema_name = n.nspname;
